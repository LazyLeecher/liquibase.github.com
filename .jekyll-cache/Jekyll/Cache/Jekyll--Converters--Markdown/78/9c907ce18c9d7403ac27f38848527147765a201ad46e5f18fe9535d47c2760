I"ÿ<h3 id="the-problem">The Problem</h3>

<p>Writing unit tests for code that accesses a database is a difficult problem, and itâ€™s one Iâ€™ve struggled with for several years.  The problems come down to a balancing act between several (often competing) requirements:</p>

<ol>
  <li>The unit test must not not break due to changes outside the class under test.</li>
  <li>The unit test must not break due to code refactoring that doesnâ€™t break functionality.</li>
  <li>The unit test must run very fast.</li>
  <li>The unit test must remain valid through database refactorings.</li>
  <li>The unit test must fail if the code doesnâ€™t function correctly.</li>
</ol>

<p>Iâ€™ve tried several approaches in the past and was unsatisfied with them:</p>

<h3 id="mock-the-database-connection">Mock the Database Connection</h3>

<p>This is the most â€œpureâ€ unit testing approach because it completely isolates the class under test from all external dependencies.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Connection conn = createMock(Connection.class);
Statement statement = createMock(Statement.class);
expect(conn.createStatement()).andReturn(statement);
expect(statement.execute("SELECT ID FROM PERSON;")).andStubReturn(true);
statement.close();
expectLastCall();
replay(conn);
replay(statement);

ClassUnderTest classUnderTest = new ClassUnderTest ();
classUnderTest .findPersonIds();

verify(conn);
verify(statement);
</code></pre></div></div>

<p>The advantages to mocking the database connection is that the tests run fast and donâ€™t change to due to creating of other unit tests.</p>

<p>In practice, however, Iâ€™ve found these tests to be more or less worthless.  They (like most mock tests) really just test the implementation of the method, not the behavior of the method, and therefore often fail due to code refactoring.  The biggest problem, however, is that the access to the database is really the whole point of the method and there are so many ways that can fail.</p>

<p>I would argue, that really the method is implemented as SQL with a Java wrapper around it and in the mock unit test, only the Java code is really testedâ€“the SQL is often just cut and pasted from what is in the method.</p>

<p>Throw in changes to the database over the life of the project (the â€œpersonâ€ table name changes to â€œemployeeâ€) and you end up with tests that pass, but donâ€™t really tell you if your code will work.</p>

<h3 id="create-test-data-sets-for-each-test">Create Test Data Sets For Each Test</h3>

<p>The obvious response to the problems with mock database tests is to have your tests access an actual database.  This method will create tests that actually fail if your SQL is wrong or your database schema changes without a corresponding code update, but brings with it its own difficulties, primarily with keeping the database in a known state.  There are tools available such as <a href="http://www.dbunit.org/">DbUnit</a> and <a href="http://unitils.sourceforge.net/summary.html">Unitils</a> to help with the test-data management, but these have disadvantages.</p>

<p>The main problem is that the way the test data is stored, it is very dependent on the exact schema when it was created, and if your database structure changes your test data can no longer be inserted and your tests are now worthless.  For example, if your test is created with test data that inserts rows into a â€œpersonâ€ table, but later that table is renamed to â€œemployeeâ€, your insert statements will no longer execute.  Depending on the schema changes, you may be able to recover your test data with a search and replace, but often the changes are too much and it has been long enough since you wrote the test that you donâ€™t remember exactly what was supposed to be in the data.</p>

<p>Additionally, the data is inserted as part of the setup method for each test.  Accessing databases in Unit tests slows them down considerably already, we should work to minimize any calls to the database that we have to do.</p>

<h3 id="manage-test-data-with-all-other-database-changes">Manage Test Data With All Other Database Changes</h3>

<p>To solve the problem of keeping test data definitions from getting out of sync with the schema, you need to have your test data built up along with your database so it will be modified by database refactoring that were made after it was initially created.  For example, here is a database change script:</p>

<ol>
  <li>create table person</li>
  <li>insert row into person <code class="highlighter-rouge">test data</code></li>
  <li>insert row into person <code class="highlighter-rouge">test data</code></li>
  <li>rename table person to employee</li>
</ol>

<p>By including the test data with your database changes, the data is automatically kept up in the same way the production data would be.  Using this technique over the dataset per method also has the advantage of performing better because the data is only inserted once, but it has the disadvantage that you need to handle all the test data that any method would want in one place.
To facilitate this technique, I built the idea of <a href="http://www.liquibase.org/manual/latest/contexts.html">execution contexts</a> into Liquibase so you can mark the test data changes and only apply them in environments where you run unit tests.  So far I have been happy with the results.  The tests fail when there is a differences between the database schema and what the code is expecting or when there is a bug in my SQL and I havenâ€™t lost any tests due to database refactorings.</p>

<p>The tests donâ€™t run as fast as mock connection tests would, but they arenâ€™t prohibitively slow.  We have over 1000 unit tests in one project that all run in about a minute.  It would be better if they would all run in 10 seconds, but what good are fast tests that donâ€™t actually test whatâ€™s important?  Just remember to mock the (already tested) data access layer in higher layers of your code so you donâ€™t take the database performance hit any more than you need to.</p>

<p>With this technique, you need to always remember that your test data set will evolve over time and write your tests accordingly, but how to do that will be covered in a <a href="http://www.liquibase.org/2007/06/building-database-tests-that-dont-break.html">later blog posting</a>.</p>

:ET