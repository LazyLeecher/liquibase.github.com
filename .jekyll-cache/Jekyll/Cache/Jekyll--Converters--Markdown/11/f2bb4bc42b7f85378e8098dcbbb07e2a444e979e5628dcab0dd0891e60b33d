I"<p>As a QA team member, you always make sure you are testing the current version of an application. However, it is just as important that the testing schema is correct and that there are no unexpected changes that the developers have applied to their environment that you do not know about.</p>

<p>Beyond the simple structure of the database, it is important that QA teams ensure the data migration from one version to the next is correct. This allows test team members to verify there is no lost or corrupted data.</p>

<p>By introducing Liquibase into your organization, QA test team members are able to know that what you are testing is what will be released‚Äìfrom the UI to database.</p>

<h3 id="know-you-have-the-correct-database-schema">Know you have the correct database schema</h3>

<p>Liquibase <a href="/documentation/databasechangelog.html">tracks which changelog statements</a> have run against each database, so you can be certain that the schema you are using for test matches what the developers expect. Even better, QA teams will know that the schema will match what goes to production so you there will be no unexpected ‚Äúwhy wasn‚Äôt this tested?‚Äù surprises.</p>

<h3 id="easier-test-data-management">Easier test data management</h3>

<p>Normally, test data is stored in something like CSV files which are loaded into the database after it is built. The problem with this strategy is that schema changes usually can and will break something in the data load process. Typically this leads to QA teams spending hours trying to figure out what the test data was trying to expose and then adjusting the files to match the new schema.</p>

<p>Instead of loading the data into the final schema, build up the test data within your changelog file. Use <a href="/documentation/changes/load_data.html">loadData</a> or <a href="/documentation/changes/sql.html">standard sql</a> to load data into the schema as it is now, then as new schema changes are appended to the changelog the test data will be migrated just like production data. This not only QA team members from having to continually update CSV files, but also helps verify that existing data is handled correctly.</p>

<p>Another best practice is to use <a href="/documentation/contexts.html">contexts</a> and labels to mark which changeSets contain test data so they are not deployed to production.</p>

<h3 id="sanity-checks">Sanity checks</h3>

<p>Liquibase ships with several tools QA teams can use to: check current database state, make sure changes are being applied correctly and ensure that no one is sneaking-in changes out of process.</p>

<ul>
  <li>The status and validate commands report on what changeSets have not yet been run and checks the changelog for errors.</li>
  <li>The <a href="/documentation/diff.html">diff</a> command reports on differences between databases to ensure that two fully updated databases are truly identical</li>
  <li>The <a href="/documentation/dbdoc.html">dbdoc</a> command generates documentation on the current database structure and its changes over time</li>
</ul>

<h3 id="enterprise-features-with-datical">Enterprise features with Datical</h3>

<p>If your QA team finds their requirements extend beyond all these great capabilities check out Datical. Datical builds upon Liquibase and lets test teams:</p>

<ul>
  <li>Simulate or rehearse database deployments to <a href="http://www.datical.com/product/packaging-intelligence/">forecast potential errors</a></li>
  <li><a href="http://www.datical.com/product/management-intelligence/">Know the development status</a> of every schema in the database</li>
  <li>Automate database <a href="http://www.datical.com/product/validation-intelligence/">change validation</a></li>
</ul>

<p>More information on Datical DB can be <a href="http://www.datical.com/product-information/">found here</a>.</p>

:ET