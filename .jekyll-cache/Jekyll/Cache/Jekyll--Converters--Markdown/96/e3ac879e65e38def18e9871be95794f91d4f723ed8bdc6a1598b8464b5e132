I"O<p>There are many, many different processes and requirements companies have for managing their database schemas. Some allow the application to directly manage them on startup, some require SQL scripts be executed by hand. Some have schemas that can differ across customers, some have only one database to deal with.</p>

<p>For people who prefer to execute SQL themselves, Liquibase has always supported an ‚ÄúupdateSQL‚Äù mode which does not update the database but instead outputs what would be run. This allows developers and DBAs to know exactly what will be ran and even make modifications as needed before actually executing the script.</p>

<p>Before version 3.2, however, Liquibase required an active database connection for updateSQL. It used that connection to determine the SQL dialect to use and to query the DATABASECHANGELOG table to learn what changeSets have already been executed.</p>

<h3 id="controlling-updatesql-sql-syntax">Controlling updateSql SQL Syntax</h3>

<p>With version 3.2, Liquibase added a new ‚Äúoffline‚Äù mode. Instead of specifying a jdbc url such as <code class="highlighter-rouge">jdbc:mysql://localhost/lbcat</code> you can use <code class="highlighter-rouge">offline:mysql</code> or <code class="highlighter-rouge">offline:postgresql</code> which lets Liquibase know what dialect to use. For finer dialect control, you can specify parameters like <code class="highlighter-rouge">offline:mysql?version=3.4&amp;caseSensitive=false</code></p>

<p>Available dialect parameters:</p>

<ul>
  <li><strong>version:</strong> Standard X.Y.Z version of the database</li>
  <li><strong>productName:</strong> String description of the database, like the JDBC driver would return</li>
  <li><strong>catalog:</strong> String containing the name of the default top-level container (‚Äòdatabase‚Äô in some databases ‚Äòschema‚Äô in others)</li>
  <li><strong>caseSensitive:</strong> Boolean value specifying if the database is case sensitive or not</li>
</ul>

<h3 id="tracking-history-with-csv">Tracking History With CSV</h3>

<p>These parameters let Liquibase know what SQL to generate for each changeSet, but without an active database connection you cannot rely on the DATABASECHANGELOG table to track what changeSets have already been ran. Instead, offline mode uses a CSV file which mimics the structure of the DATABASECHANGELOG table.</p>

<p>By default, Liquibase will use a file called ‚Äúdatabasechangelog.csv‚Äù in the working directory, but it can be specified with a ‚ÄúchangeLogFile‚Äù parameter such as <code class="highlighter-rouge">offline:mssql?changeLogFile=path/to/file.csv</code></p>

<p>It is up to you to ensure that the contents of the csv file match what is in the database. Running updateSQL automatically appends to the CSV file under the assumption that you will apply the SQL to the database. Since the csv file matches a particular database, it isn‚Äôt something you normally would store or share under version control because every database can (and probably will) be in a different state. If you do store the files in a central location, you will probably want to at least have a separate file for each database.</p>

<p>By default, the SQL generated by updateSql in offline mode will still contain the standard DATABASECHANGELOG insert statements, so each database that you apply the SQL to will still have a correct DATABASECHANGELOG table. This means that you can switch between a direct-connection update and offline updateSQL as needed. It also means that you can also extract the current contents of the DATABASECHANGELOG table to a CSV file and use that as the file passed to the offline connection to ensure you have the right contents in the file.</p>

<p>If you do not want the DATABASECHANGELOG table SQL included in updateSQL output, there is an ‚ÄúoutputLiquibaseSql‚Äù parameter which can be passed in your offline url.</p>

<p>Possible outputLiquibaseSql values:</p>

<ul>
  <li><strong>‚Äúnone‚Äù</strong> will output no DATABASECHANGELOG statements</li>
  <li><strong>‚Äúdata_only‚Äù</strong> will output only INSERT INTO DATABASECHANGELOG statements</li>
  <li><strong>‚Äúall‚Äù</strong> will output CREATE TABLE DATABASECHANGELOG if the csv file does not exist as well as INSERT statements  (default value)</li>
</ul>

<h3 id="offline-snapshots">Offline Snapshots</h3>

<p>The new 3.4.0 release of Liquibase expands The new 3.4.0 release of Liquibase expands offline support with a new ‚Äúsnapshot‚Äù parameter which can be passed to the offline url pointing to a saved database structure. Liquibase will use the snapshot anywhere it would have normally needed to read the current database state. This allows you to use preconditions and perform diff and diffChangeLog operations without an active connection and even between snapshots of the same database from different points in time.</p>

<p>To create a snapshot of your live databases, use the <code class="highlighter-rouge">‚ÄîsnapshotFormat=json</code> parameter on the ‚Äúsnapshot‚Äù command.</p>

<p>Command line example:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>liquibase <span class="nt">--url</span><span class="o">=</span>jdbc:mysql://localhost/lbcat snapshot <span class="nt">--snapshotFormat</span><span class="o">=</span>json <span class="o">&gt;</span> snapshot.json</code></pre></figure>

<p>or</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>liquibase <span class="nt">--url</span><span class="o">=</span>jdbc:mysql://localhost/lbcat <span class="nt">--outputFile</span><span class="o">=</span>path/to/output.json snapshot <span class="nt">--snapshotFormat</span><span class="o">=</span>json</code></pre></figure>

<p>NOTE: currently only ‚Äújson‚Äù is supported as a snapshotFormat.</p>

<p>You can then use that file with your offline url and any snapshot operations will use it as the database state.</p>

<ul>
  <li><strong>liquibase ‚Äìurl=jdbc:mysql://localhost/lbcat ‚ÄìreferenceUrl=offline:mysql?snapshot=path/to/snapshot.json diff</strong> will compare the stored snapshot with the current database state</li>
  <li><strong>liquibase ‚Äìurl=offline:mysql?snapshot=path/to/snapshot.json diff ‚ÄìreferenceUrl=offline:mysql?snapshot=path/to/older-snapshot.json diff</strong> will compare two snapshots</li>
  <li><strong>liquibase ‚Äìurl=offline:mysql?snapshot=path/to/snapshot.json generateChangeLog</strong> will generate a changelog based on what is in the snapshot</li>
  <li><strong>liquibase ‚Äìurl=jdbc:mysql://localhost/lbcat ‚ÄìreferenceUrl=offline:mysql?snapshot=path/to/snapshot.json diffChangeLog</strong> will generate a changelog based on what is new in the real database compared to what is in the snapshot.</li>
</ul>

<p><em>Originally posted to <a href="http://java.dzone.com/articles/using-liquibase-without">java.dzone.com</a></em></p>
:ET